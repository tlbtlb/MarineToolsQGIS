# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BathyMorph
                                 A QGIS plugin
 Calculates Slope Contours and fills small gaps in bathymetry 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-03-10
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Dr Tim Le Bas, National Oceanography Centre, Southampton . UK
        email                : tim.lebas@noc.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.PyQt.QtWidgets import QAction,QFileDialog 
from qgis.core import QgsProject 

# Import the code for the dialog
from .BathyMorph_dialog import BathyMorphDialog
import os.path
from qgis.core import Qgis,QgsMessageLog
from qgis.gui import QgsMessageBar

from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterRasterLayer
from qgis.core import QgsProcessingParameterRasterDestination
from qgis.core import QgsProcessingParameterDefinition
from qgis.core import QgsVectorLayer
from qgis.core import (QgsSymbol,QgsSimpleFillSymbolLayer,QgsRendererCategory,QgsCategorizedSymbolRenderer)
from qgis.core import QgsRasterLayer
from qgis.core import QgsRasterBandStats

import processing
import sys
import traceback
import os, glob

class BathyMorph:
    """QGIS Plugin Implementation."""

    def select_input_file1(self): 
        filename, _filter = QFileDialog.getOpenFileName(selfMT.dlg, "Select input bathymetry file ","", '*.img *.tif*') 
        selfMT.dlg.lineEdit_1.setText(filename) 
        #autofill
        autoPoly = filename[:-4]+"_interp.img"
        selfMT.dlg.lineEdit_2.setText(autoPoly)
        if os.path.exists(autoPoly):
            selfMT.dlg.exists1.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists1.setText("")
        autoPoly = filename[:-4]+"_slope.img"
        selfMT.dlg.lineEdit_3.setText(autoPoly)
        if os.path.exists(autoPoly):
            selfMT.dlg.exists2.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists2.setText("")
        autoPoly = filename[:-4]+"_contours.shp"
        selfMT.dlg.lineEdit_4.setText(autoPoly)
        if os.path.exists(autoPoly):
            selfMT.dlg.exists5.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists5.setText("")
        autoPoly = filename[:-4]+"_roughness.img"
        selfMT.dlg.lineEdit_5.setText(autoPoly)
        if os.path.exists(autoPoly):
            selfMT.dlg.exists3.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists3.setText("")
        autoPoly = filename[:-4]+"_hires.img"
        selfMT.dlg.lineEdit_6.setText(autoPoly)
        if os.path.exists(autoPoly):
            selfMT.dlg.exists4.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists4.setText("")
    def select_input_file2(self): 
        filename, _filter = QFileDialog.getSaveFileName(selfMT.dlg, "Select output interpolated file ","", '*.img') 
        selfMT.dlg.lineEdit_2.setText(filename) 
        if os.path.exists(filename):
            selfMT.dlg.exists1.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists1.setText("")
    def select_input_file3(self): 
        filename, _filter = QFileDialog.getSaveFileName(selfMT.dlg, "Select output slope file","", '*.img') 
        selfMT.dlg.lineEdit_3.setText(filename) 
        if os.path.exists(filename):
            selfMT.dlg.exists2.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists2.setText("")
    def select_input_file4(self): 
        filename, _filter = QFileDialog.getSaveFileName(selfMT.dlg, "Select output contours shapefile","", '*.shp') 
        selfMT.dlg.lineEdit_4.setText(filename) 
        if os.path.exists(filename):
            selfMT.dlg.exists5.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists5.setText("")
    def select_input_file5(self): 
        filename, _filter = QFileDialog.getSaveFileName(selfMT.dlg, "Select output roughness file","", '*.img') 
        selfMT.dlg.lineEdit_5.setText(filename) 
        if os.path.exists(filename):
            selfMT.dlg.exists3.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists3.setText("")         
    def select_input_file6(self): 
        filename, _filter = QFileDialog.getSaveFileName(selfMT.dlg, "Select output high resolution file","", '*.img') 
        selfMT.dlg.lineEdit_6.setText(filename) 
        if os.path.exists(filename):
            selfMT.dlg.exists4.setText("Existing file will be overwritten")
        else:
            selfMT.dlg.exists4.setText("")
    def help(self): 
        import webbrowser
        import marinetools
        MThelp = os.path.dirname(marinetools.__file__) + "\\bathymorph\\BathyMorph.pdf"
        webbrowser.open(MThelp)  

    def run(self):
        import random
        import marinetools
        from marinetools.bathymorph.BathyMorph_dialog import BathyMorphDialog
        global selfMT
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = BathyMorphDialog()
            selfMT = self
            self.dlg.pushButton_1.clicked.connect(BathyMorph.select_input_file1) 
            self.dlg.pushButton_2.clicked.connect(BathyMorph.select_input_file2) 
            self.dlg.pushButton_3.clicked.connect(BathyMorph.select_input_file3) 
            self.dlg.pushButton_4.clicked.connect(BathyMorph.select_input_file4) 
            self.dlg.pushButton_5.clicked.connect(BathyMorph.select_input_file5) 
            self.dlg.pushButton_6.clicked.connect(BathyMorph.select_input_file6) 
            self.dlg.helpButton.clicked.connect(BathyMorph.help) 
            
        # Fetch the currently loaded layers
        layers = QgsProject.instance().layerTreeRoot().children() 
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        
        # See if OK was pressed

        if result:
            import glob
            filename1 = self.dlg.lineEdit_1.text()  
            filename2 = self.dlg.lineEdit_2.text()  
            filename3 = self.dlg.lineEdit_3.text()  
            filename4 = self.dlg.lineEdit_4.text()  
            filename5 = self.dlg.lineEdit_5.text()  
            filename6 = self.dlg.lineEdit_6.text()
            if os.path.exists(filename2):
                os.remove(filename2)
            if os.path.exists(filename3):
                os.remove(filename3)
            if os.path.exists(filename4):
                os.remove(filename4)
            if os.path.exists(filename5):
                os.remove(filename5)
            if os.path.exists(filename6):
                os.remove(filename6)

            Smooth = self.dlg.SmoothingFactor.text()
            Interval = self.dlg.ContourInterval.text()
            Resolution = self.dlg.ResolutionOut.text()
            if Smooth == "":
                Smooth = "7"
            if Interval == "":
                Interval = "10"
            if Resolution == "":
                Resolution = "100"
            if self.dlg.DoInterpolate.isChecked() == True:
                DoInterp=1
            else:
                DoInterp=0
            if self.dlg.DoSlope.isChecked() == True:
                DoSlope=1
            else:
                DoSlope=0
            if self.dlg.DoContours.isChecked() == True:
                DoContours=1
            else:
                DoContours=0
            if self.dlg.DoRoughness.isChecked() == True:
                DoRoughness=1
            else:
                DoRoughness=0
            if self.dlg.DoHiRes.isChecked() == True:
                DoHiRes=1
            else:
                DoHiRes=0
             
            newdir = str(os.path.dirname(filename1) + "/tempMT")
            if not os.path.exists(newdir):
                os.mkdir(newdir)
            
            alphabet = 'ZYXWVUTSRQPONMLKJIHGFEDCBA0987654321'
            rand = alphabet[random.randint(1,25)] + alphabet[random.randint(1,35)] + alphabet[random.randint(1,35)] + alphabet[random.randint(1,35)]
            
            if DoInterp:
                # Interpolate output to filename2
                newInterp = filename2
                processing.run("gdal:fillnodata", {'INPUT':filename1,'BAND':1,'DISTANCE':7,'ITERATIONS':0,'NO_MASK':False,'MASK_LAYER':None,'OPTIONS':'','EXTRA':'','OUTPUT':filename2})
            else:
                newInterp = filename1

            if DoSlope:
                # Calculate Slope output to filename3 but use newInterp
                processing.run("native:slope", {'INPUT':newInterp,'Z_FACTOR':1,'OUTPUT':filename3})
                fname = os.path.dirname(str(filename3))
                vlayer = QgsRasterLayer(str(filename3), str(filename3[len(fname)+1:]))
                QgsProject.instance().addMapLayer(vlayer)
                
            if DoInterp:
                fname = os.path.dirname(str(newInterp))
                vlayer = QgsRasterLayer(str(newInterp), str(filename2[len(fname)+1:]))
                QgsProject.instance().addMapLayer(vlayer)

            if DoContours:
                # make contours output to filename4 but use newInterp
                dict = processing.run("native:rasterlayerproperties", {'INPUT':newInterp,'BAND':1})
                cellsizeX = float(dict['PIXEL_WIDTH'])
                cutoff = cellsizeX * 10.0
                result = processing.run("gdal:contour", {'INPUT':newInterp,'BAND':1,'INTERVAL':Interval,'FIELD_NAME':'ELEV','CREATE_3D':False,'IGNORE_NODATA':False,'NODATA':None,'OFFSET':0,'EXTRA':'','OUTPUT':'TEMPORARY_OUTPUT'})
                newContour1 = result['OUTPUT']
                result = processing.run("qgis:exportaddgeometrycolumns", {'INPUT':newContour1,'CALC_METHOD':0,'OUTPUT':'TEMPORARY_OUTPUT'})
                newContour2 = result['OUTPUT']
                processing.run("native:extractbyattribute", {'INPUT':newContour2,'FIELD':'length','OPERATOR':2,'VALUE':cutoff,'OUTPUT':filename4})
                fname = os.path.dirname(str(filename4))
                vlayer = QgsVectorLayer(str(filename4), str(filename4[len(fname)+1:]), "ogr")
                QgsProject.instance().addMapLayer(vlayer)

            if DoRoughness:
                # Calculate Roughness output to filename5 but use newInterp
                newRoughness = newdir + "/newRoughness"+rand+".img"
                processing.run("gdal:roughness", {'INPUT':newInterp,'BAND':1,'COMPUTE_EDGES':False,'OPTIONS':'','OUTPUT':filename5})
                fname = os.path.dirname(str(filename5))
                vlayer = QgsRasterLayer(str(filename5), str(filename5[len(fname)+1:]))
                QgsProject.instance().addMapLayer(vlayer)

            if DoHiRes:
                # Make interpolated output to filename6 but use newInterp
                newHiRes = newdir + "/newHiRes"+rand+".gpkg"
                outTin = newdir + "/outTin"+rand+".img"
                processing.run("native:pixelstopoints", {'INPUT_RASTER':newInterp,'RASTER_BAND':1,'FIELD_NAME':'VALUE','OUTPUT':newHiRes})
                #result = processing.run("native:pixelstopoints", {'INPUT_RASTER':newInterp,'RASTER_BAND':1,'FIELD_NAME':'VALUE','OUTPUT':'TEMPORARY_OUTPUT'})
                #newHiRes = result['OUTPUT']
                expr = newHiRes + '|layername=newHiRes'+rand+'::~::0::~::1::~::0'
                extent = QgsVectorLayer(newdir + "/newHiRes"+rand+".gpkg").extent()
                crs = QgsVectorLayer(newdir + "/newHiRes"+rand+".gpkg").crs()
                processing.run("qgis:tininterpolation", {'INTERPOLATION_DATA':expr,'METHOD':0,'EXTENT':extent,'PIXEL_SIZE':Resolution,'OUTPUT':outTin})
                #result = processing.run("qgis:tininterpolation", {'INTERPOLATION_DATA':expr,'METHOD':0,'EXTENT':extent,'PIXEL_SIZE':Resolution,'OUTPUT':'TEMPORARY_OUTPUT'})
                #outTin = result['OUTPUT']
                tempName = os.path.split(newInterp)[1]
                name = tempName.split('.')[0]
                InRef = name + '@1'
                tempName = os.path.split(outTin)[1]
                name = tempName.split('.')[0]
                TinRef = name + '@1'
                expression = '"' + TinRef + '" * "' + InRef + '" / "' + InRef + '"'
                processing.run("qgis:rastercalculator", {'EXPRESSION':expression,'LAYERS':[outTin],'CELLSIZE':None,'EXTENT':None,'CRS':None,'OUTPUT':filename6})
                fname = os.path.dirname(str(filename6))
                vlayer = QgsRasterLayer(str(filename6), str(filename6[len(fname)+1:]))
                QgsProject.instance().addMapLayer(vlayer)
            try:
                os.rmdir(newdir)
            except:
                print("Temporary directory is not empty to delete")
            pass

